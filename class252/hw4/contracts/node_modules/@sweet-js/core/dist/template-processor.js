'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processTemplate = processTemplate;
exports.replaceTemplate = replaceTemplate;

var _immutable = require('immutable');

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _errors = require('./errors');

var _sweetSpec = require('sweet-spec');

var T = _interopRequireWildcard(_sweetSpec);

var _syntax = require('./syntax');

var _syntax2 = _interopRequireDefault(_syntax);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
Given a syntax list like:

  [foo, bar, $, { 42, +, 24 }, baz]

convert it to:

  [foo, bar, $, { 0 }, baz]

and return another list with the interpolated values at the corresponding
positions.

Requires either lookahead/lookbehind of one (to see the $).
*/

const isDolar = s => s instanceof T.RawSyntax && typeof s.value.match === 'function' && s.value.match('identifier') && s.value.val() === '$';
const isDelimiter = s => s instanceof T.RawDelimiter;
const isBraces = s => s instanceof T.RawDelimiter && s.kind === 'braces';
const isParens = s => s instanceof T.RawDelimiter && s.kind === 'parens';
const isBrackets = s => s instanceof T.RawDelimiter && s.kind === 'brackets';

const mkDelimiter = (kind, inner, from) => {
  return new T.RawDelimiter({
    kind,
    // $FlowFixMe: flow doesn't know arrays are actually lists
    inner: _immutable.List.of(from.inner.first()).concat(inner).concat(from.inner.last())
  });
};

const insertIntoDelimiter = _ramda2.default.cond([[isBraces, (s, r) => mkDelimiter('braces', r, s)], [isParens, (s, r) => mkDelimiter('parens', r, s)], [isBrackets, (s, r) => mkDelimiter('brackets', r, s)]]);

const process = (acc, s) => {
  if (isBraces(s) && isDolar(acc.template.last())) {
    let idx = _syntax2.default.fromNumber(acc.interp.size, s.inner.first().value);
    return {
      template: acc.template.push(mkDelimiter('braces', _immutable.List.of(new T.RawSyntax({
        value: idx
      })), s)),
      interp: acc.interp.push(s.inner.slice(1, s.inner.size - 1))
    };
  } else if (isDelimiter(s)) {
    let innerResult = processTemplate(s.inner.slice(1, s.inner.size - 1), acc.interp);
    return {
      template: acc.template.push(insertIntoDelimiter(s, innerResult.template)),
      interp: innerResult.interp
    };
  } else {
    return {
      template: acc.template.push(s),
      interp: acc.interp
    };
  }
};

function getLineNumber(t) {
  if (t instanceof T.RawSyntax) {
    return t.value.lineNumber();
  }
  return t.inner.first().value.lineNumber();
}

function setLineNumber(t, lineNumber) {
  if (t instanceof T.RawSyntax) {
    return t.extend({
      value: t.value.setLineNumber(lineNumber)
    });
  } else if (t instanceof T.RawDelimiter) {
    return t.extend({
      inner: t.inner.map(tt => setLineNumber(tt, lineNumber))
    });
  } else if (_immutable.List.isList(t)) {
    return t.map(tt => setLineNumber(tt, lineNumber));
  }
  // TODO: need to handle line numbers for all AST nodes
  return t;
}

function cloneLineNumber(to, from) {
  if (from && to) {
    return setLineNumber(to, getLineNumber(from));
  }
  return to;
}

const replace = (acc, s) => {
  let last = acc.template.get(-1);
  let beforeLast = acc.template.get(-2);
  if (isBraces(s) && isDolar(last)) {
    let index = s.inner.get(1).value.val();
    (0, _errors.assert)(acc.rep.size > index, 'unknown replacement value');
    // TODO: figure out holistic solution to line nubmers and ASI
    let replacement = cloneLineNumber(acc.rep.get(index), beforeLast);
    // let replacement = acc.rep.get(index);
    return {
      template: acc.template.pop().concat(replacement),
      rep: acc.rep
    };
  } else if (isDelimiter(s)) {
    let innerResult = replaceTemplate(s.inner.slice(1, s.inner.size - 1), acc.rep);
    return {
      template: acc.template.push(insertIntoDelimiter(s, innerResult)),
      rep: acc.rep
    };
  } else {
    return {
      template: acc.template.push(s),
      rep: acc.rep
    };
  }
};

function processTemplate(temp, interp = (0, _immutable.List)()) {
  return temp.reduce(process, { template: (0, _immutable.List)(), interp });
}

function replaceTemplate(temp, rep) {
  return temp.reduce(replace, { template: (0, _immutable.List)(), rep }).template;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZW1wbGF0ZS1wcm9jZXNzb3IuanMiXSwibmFtZXMiOlsicHJvY2Vzc1RlbXBsYXRlIiwicmVwbGFjZVRlbXBsYXRlIiwiVCIsImlzRG9sYXIiLCJzIiwiUmF3U3ludGF4IiwidmFsdWUiLCJtYXRjaCIsInZhbCIsImlzRGVsaW1pdGVyIiwiUmF3RGVsaW1pdGVyIiwiaXNCcmFjZXMiLCJraW5kIiwiaXNQYXJlbnMiLCJpc0JyYWNrZXRzIiwibWtEZWxpbWl0ZXIiLCJpbm5lciIsImZyb20iLCJvZiIsImZpcnN0IiwiY29uY2F0IiwibGFzdCIsImluc2VydEludG9EZWxpbWl0ZXIiLCJjb25kIiwiciIsInByb2Nlc3MiLCJhY2MiLCJ0ZW1wbGF0ZSIsImlkeCIsImZyb21OdW1iZXIiLCJpbnRlcnAiLCJzaXplIiwicHVzaCIsInNsaWNlIiwiaW5uZXJSZXN1bHQiLCJnZXRMaW5lTnVtYmVyIiwidCIsImxpbmVOdW1iZXIiLCJzZXRMaW5lTnVtYmVyIiwiZXh0ZW5kIiwibWFwIiwidHQiLCJpc0xpc3QiLCJjbG9uZUxpbmVOdW1iZXIiLCJ0byIsInJlcGxhY2UiLCJnZXQiLCJiZWZvcmVMYXN0IiwiaW5kZXgiLCJyZXAiLCJyZXBsYWNlbWVudCIsInBvcCIsInRlbXAiLCJyZWR1Y2UiXSwibWFwcGluZ3MiOiI7Ozs7O1FBMEpnQkEsZSxHQUFBQSxlO1FBT0FDLGUsR0FBQUEsZTs7QUFqS2hCOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0lBQVlDLEM7O0FBQ1o7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE1BQU1DLFVBQVdDLENBQUQsSUFDZEEsYUFBYUYsRUFBRUcsU0FBZixJQUNBLE9BQU9ELEVBQUVFLEtBQUYsQ0FBUUMsS0FBZixLQUF5QixVQUR6QixJQUVBSCxFQUFFRSxLQUFGLENBQVFDLEtBQVIsQ0FBYyxZQUFkLENBRkEsSUFHQUgsRUFBRUUsS0FBRixDQUFRRSxHQUFSLE9BQWtCLEdBSnBCO0FBS0EsTUFBTUMsY0FBZUwsQ0FB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QUosQ0FBYUssSUFBYixDQUFrQjVCLENBQWxCLENBREw7QUFFTDZDLFdBQUt2QixJQUFJdUI7QUFGSixLQUFQO0FBSUQ7QUFDRixDQS9CRDs7QUFpQ08sU0FBU2pELGVBQVQsQ0FDTG9ELElBREssRUFFTHRCLFNBQTZCLHNCQUZ4QixFQUdMO0FBQ0EsU0FBT3NCLEtBQUtDLE1BQUwsQ0FBWTVCLE9BQVosRUFBcUIsRUFBRUUsVUFBVSxzQkFBWixFQUFvQkcsTUFBcEIsRUFBckIsQ0FBUDtBQUNEOztBQUVNLFNBQVM3QixlQUFULENBQXlCbUQsSUFBekIsRUFBbURILEdBQW5ELEVBQTZEO0FBQ2xFLFNBQU9HLEtBQUtDLE1BQUwsQ0FBWVIsT0FBWixFQUFxQixFQUFFbEIsVUFBVSxzQkFBWixFQUFvQnNCLEdBQXBCLEVBQXJCLEVBQWdEdEIsUUFBdkQ7QUFDRCIsImZpbGUiOiJ0ZW1wbGF0ZS1wcm9jZXNzb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBfIGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCAqIGFzIFQgZnJvbSAnc3dlZXQtc3BlYyc7XG5pbXBvcnQgU3ludGF4IGZyb20gJy4vc3ludGF4JztcblxuLypcbkdpdmVuIGEgc3ludGF4IGxpc3QgbGlrZTpcblxuICBbZm9vLCBiYXIsICQsIHsgNDIsICssIDI0IH0sIGJhel1cblxuY29udmVydCBpdCB0bzpcblxuICBbZm9vLCBiYXIsICQsIHsgMCB9LCBiYXpdXG5cbmFuZCByZXR1cm4gYW5vdGhlciBsaXN0IHdpdGggdGhlIGludGVycG9sYXRlZCB2YWx1ZXMgYXQgdGhlIGNvcnJlc3BvbmRpbmdcbnBvc2l0aW9ucy5cblxuUmVxdWlyZXMgZWl0aGVyIGxvb2thaGVhZC9sb29rYmVoaW5kIG9mIG9uZSAodG8gc2VlIHRoZSAkKS5cbiovXG5cbmNvbnN0IGlzRG9sYXIgPSAoczogVC5TeW50YXhUZXJtKSA9PlxuICBzIGluc3RhbmNlb2YgVC5SYXdTeW50YXggJiZcbiAgdHlwZW9mIHMudmFsdWUubWF0Y2ggPT09ICdmdW5jdGlvbicgJiZcbiAgcy52YWx1ZS5tYXRjaCgnaWRlbnRpZmllcicpICYmXG4gIHMudmFsdWUudmFsKCkgPT09ICckJztcbmNvbnN0IGlzRGVsaW1pdGVyID0gKHM6IFQuU3ludGF4VGVybSkgPT4gcyBpbnN0YW5jZW9mIFQuUmF3RGVsaW1pdGVyO1xuY29uc3QgaXNCcmFjZXMgPSAoczogVC5TeW50YXhUZXJtKSA9PlxuICBzIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIgJiYgcy5raW5kID09PSAnYnJhY2VzJztcbmNvbnN0IGlzUGFyZW5zID0gKHM6IFQuU3ludGF4VGVybSkgPT5cbiAgcyBpbnN0YW5jZW9mIFQuUmF3RGVsaW1pdGVyICYmIHMua2luZCA9PT0gJ3BhcmVucyc7XG5jb25zdCBpc0JyYWNrZXRzID0gKHM6IFQuU3ludGF4VGVybSkgPT5cbiAgcyBpbnN0YW5jZW9mIFQuUmF3RGVsaW1pdGVyICYmIHMua2luZCA9PT0gJ2JyYWNrZXRzJztcblxudHlwZSBEZWxpbUtpbmQgPSAnYnJhY2VzJyB8ICdwYXJlbnMnIHwgJ2JyYWNrZXRzJztcblxuY29uc3QgbWtEZWxpbWl0ZXIgPSAoXG4gIGtpbmQ6IERlbGltS2luZCxcbiAgaW5uZXI6IExpc3Q8VC5TeW50YXhUZXJtPixcbiAgZnJvbTogVC5SYXdEZWxpbWl0ZXIsXG4pID0+IHtcbiAgcmV0dXJuIG5ldyBULlJhd0RlbGltaXRlcih7XG4gICAga2luZCxcbiAgICAvLyAkRmxvd0ZpeE1lOiBmbG93IGRvZXNuJ3Qga25vdyBhcnJheXMgYXJlIGFjdHVhbGx5IGxpc3RzXG4gICAgaW5uZXI6IExpc3Qub2YoZnJvbS5pbm5lci5maXJzdCgpKS5jb25jYXQoaW5uZXIpLmNvbmNhdChmcm9tLmlubmVyLmxhc3QoKSksXG4gIH0pO1xufTtcblxuY29uc3QgaW5zZXJ0SW50b0RlbGltaXRlciA9IF8uY29uZChbXG4gIFtpc0JyYWNlcywgKHMsIHIpID0+IG1rRGVsaW1pdGVyKCdicmFjZXMnLCByLCBzKV0sXG4gIFtpc1BhcmVucywgKHMsIHIpID0+IG1rRGVsaW1pdGVyKCdwYXJlbnMnLCByLCBzKV0sXG4gIFtpc0JyYWNrZXRzLCAocywgcikgPT4gbWtEZWxpbWl0ZXIoJ2JyYWNrZXRzJywgciwgcyldLFxuXSk7XG5cbmNvbnN0IHByb2Nlc3MgPSAoXG4gIGFjYzogeyB0ZW1wbGF0ZTogTGlzdDxULlN5bnRheFRlcm0+LCBpbnRlcnA6IExpc3Q8TGlzdDxULlN5bnRheFRlcm0+PiB9LFxuICBzOiBULlN5bnRheFRlcm0sXG4pID0+IHtcbiAgaWYgKGlzQnJhY2VzKHMpICYmIGlzRG9sYXIoYWNjLnRlbXBsYXRlLmxhc3QoKSkpIHtcbiAgICBsZXQgaWR4ID0gU3ludGF4LmZyb21OdW1iZXIoYWNjLmludGVycC5zaXplLCBzLmlubmVyLmZpcnN0KCkudmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZTogYWNjLnRlbXBsYXRlLnB1c2goXG4gICAgICAgIG1rRGVsaW1pdGVyKFxuICAgICAgICAgICdicmFjZXMnLFxuICAgICAgICAgIExpc3Qub2YoXG4gICAgICAgICAgICBuZXcgVC5SYXdTeW50YXgoe1xuICAgICAgICAgICAgICB2YWx1ZTogaWR4LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgICBzLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICAgIGludGVycDogYWNjLmludGVycC5wdXNoKHMuaW5uZXIuc2xpY2UoMSwgcy5pbm5lci5zaXplIC0gMSkpLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNEZWxpbWl0ZXIocykpIHtcbiAgICBsZXQgaW5uZXJSZXN1bHQgPSBwcm9jZXNzVGVtcGxhdGUoXG4gICAgICBzLmlubmVyLnNsaWNlKDEsIHMuaW5uZXIuc2l6ZSAtIDEpLFxuICAgICAgYWNjLmludGVycCxcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZTogYWNjLnRlbXBsYXRlLnB1c2goaW5zZXJ0SW50b0RlbGltaXRlcihzLCBpbm5lclJlc3VsdC50ZW1wbGF0ZSkpLFxuICAgICAgaW50ZXJwOiBpbm5lclJlc3VsdC5pbnRlcnAsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVtcGxhdGU6IGFjYy50ZW1wbGF0ZS5wdXNoKHMpLFxuICAgICAgaW50ZXJwOiBhY2MuaW50ZXJwLFxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVOdW1iZXIodDogVC5TeW50YXhUZXJtKSB7XG4gIGlmICh0IGluc3RhbmNlb2YgVC5SYXdTeW50YXgpIHtcbiAgICByZXR1cm4gdC52YWx1ZS5saW5lTnVtYmVyKCk7XG4gIH1cbiAgcmV0dXJuIHQuaW5uZXIuZmlyc3QoKS52YWx1ZS5saW5lTnVtYmVyKCk7XG59XG5cbmZ1bmN0aW9uIHNldExpbmVOdW1iZXIodDogVC5UZXJtIHwgTGlzdDxULlRlcm0+LCBsaW5lTnVtYmVyOiBudW1iZXIpIHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBULlJhd1N5bnRheCkge1xuICAgIHJldHVybiB0LmV4dGVuZCh7XG4gICAgICB2YWx1ZTogdC52YWx1ZS5zZXRMaW5lTnVtYmVyKGxpbmVOdW1iZXIpLFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBULlJhd0RlbGltaXRlcikge1xuICAgIHJldHVybiB0LmV4dGVuZCh7XG4gICAgICBpbm5lcjogdC5pbm5lci5tYXAodHQgPT4gc2V0TGluZU51bWJlcih0dCwgbGluZU51bWJlcikpLFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKExpc3QuaXNMaXN0KHQpKSB7XG4gICAgcmV0dXJuIHQubWFwKHR0ID0+IHNldExpbmVOdW1iZXIodHQsIGxpbmVOdW1iZXIpKTtcbiAgfVxuICAvLyBUT0RPOiBuZWVkIHRvIGhhbmRsZSBsaW5lIG51bWJlcnMgZm9yIGFsbCBBU1Qgbm9kZXNcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lTGluZU51bWJlcih0bzogVC5UZXJtLCBmcm9tOiBULlN5bnRheFRlcm0pIHtcbiAgaWYgKGZyb20gJiYgdG8pIHtcbiAgICByZXR1cm4gc2V0TGluZU51bWJlcih0bywgZ2V0TGluZU51bWJlcihmcm9tKSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5jb25zdCByZXBsYWNlID0gKFxuICBhY2M6IHsgdGVtcGxhdGU6IExpc3Q8VC5TeW50YXhUZXJtPiwgcmVwOiBMaXN0PFQuVGVybSB8IExpc3Q8VC5UZXJtPj4gfSxcbiAgczogVC5TeW50YXhUZXJtLFxuKSA9PiB7XG4gIGxldCBsYXN0ID0gYWNjLnRlbXBsYXRlLmdldCgtMSk7XG4gIGxldCBiZWZvcmVMYXN0ID0gYWNjLnRlbXBsYXRlLmdldCgtMik7XG4gIGlmIChpc0JyYWNlcyhzKSAmJiBpc0RvbGFyKGxhc3QpKSB7XG4gICAgbGV0IGluZGV4ID0gcy5pbm5lci5nZXQoMSkudmFsdWUudmFsKCk7XG4gICAgYXNzZXJ0KGFjYy5yZXAuc2l6ZSA+IGluZGV4LCAndW5rbm93biByZXBsYWNlbWVudCB2YWx1ZScpO1xuICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG9saXN0aWMgc29sdXRpb24gdG8gbGluZSBudWJtZXJzIGFuZCBBU0lcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSBjbG9uZUxpbmVOdW1iZXIoYWNjLnJlcC5nZXQoaW5kZXgpLCBiZWZvcmVMYXN0KTtcbiAgICAvLyBsZXQgcmVwbGFjZW1lbnQgPSBhY2MucmVwLmdldChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiBhY2MudGVtcGxhdGUucG9wKCkuY29uY2F0KHJlcGxhY2VtZW50KSxcbiAgICAgIHJlcDogYWNjLnJlcCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzRGVsaW1pdGVyKHMpKSB7XG4gICAgbGV0IGlubmVyUmVzdWx0ID0gcmVwbGFjZVRlbXBsYXRlKFxuICAgICAgcy5pbm5lci5zbGljZSgxLCBzLmlubmVyLnNpemUgLSAxKSxcbiAgICAgIGFjYy5yZXAsXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGVtcGxhdGU6IGFjYy50ZW1wbGF0ZS5wdXNoKGluc2VydEludG9EZWxpbWl0ZXIocywgaW5uZXJSZXN1bHQpKSxcbiAgICAgIHJlcDogYWNjLnJlcCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZTogYWNjLnRlbXBsYXRlLnB1c2gocyksXG4gICAgICByZXA6IGFjYy5yZXAsXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NUZW1wbGF0ZShcbiAgdGVtcDogTGlzdDxULlN5bnRheFRlcm0+LFxuICBpbnRlcnA6IExpc3Q8VC5TeW50YXhUZXJtPiA9IExpc3QoKSxcbikge1xuICByZXR1cm4gdGVtcC5yZWR1Y2UocHJvY2VzcywgeyB0ZW1wbGF0ZTogTGlzdCgpLCBpbnRlcnAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcDogTGlzdDxULlN5bnRheFRlcm0+LCByZXA6IGFueSkge1xuICByZXR1cm4gdGVtcC5yZWR1Y2UocmVwbGFjZSwgeyB0ZW1wbGF0ZTogTGlzdCgpLCByZXAgfSkudGVtcGxhdGU7XG59XG4iXX0=