'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expandCompiletime = expandCompiletime;
exports.sanitizeReplacementValues = sanitizeReplacementValues;
exports.evalCompiletimeValue = evalCompiletimeValue;

var _sweetSpec = require('sweet-spec');

var S = _interopRequireWildcard(_sweetSpec);

var _ramda = require('ramda');

var _ = _interopRequireWildcard(_ramda);

var _immutable = require('immutable');

var _syntax = require('./syntax');

var _syntax2 = _interopRequireDefault(_syntax);

var _shiftCodegen = require('shift-codegen');

var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

var _sweetToShiftReducer = require('./sweet-to-shift-reducer');

var _sweetToShiftReducer2 = _interopRequireDefault(_sweetToShiftReducer);

var _termExpander = require('./term-expander');

var _termExpander2 = _interopRequireDefault(_termExpander);

var _env = require('./env');

var _env2 = _interopRequireDefault(_env);

var _templateProcessor = require('./template-processor');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function expandCompiletime(term, context) {
  // each compiletime value needs to be expanded with a fresh
  // environment and in the next higher phase
  let syntaxExpander = new _termExpander2.default(_.merge(context, {
    phase: context.phase + 1,
    env: new _env2.default(),
    store: context.store
  }));

  return syntaxExpander.expand(term);
}

function sanitizeReplacementValues(values) {
  if (Array.isArray(values)) {
    return sanitizeReplacementValues((0, _immutable.List)(values));
  } else if (_immutable.List.isList(values)) {
    return values.map(sanitizeReplacementValues);
  } else if (values == null) {
    throw new Error('replacement values for syntax template must not be null or undefined');
  } else if (typeof values.next === 'function') {
    return sanitizeReplacementValues((0, _immutable.List)(values));
  }
  return values;
}

// (Expression, Context) -> [function]
function evalCompiletimeValue(expr, context) {
  let sandbox = {
    syntaxTemplate: function (ident, ...values) {
      return (0, _templateProcessor.replaceTemplate)(context.templateMap.get(ident), sanitizeReplacementValues(values));
    }
  };

  let sandboxKeys = (0, _immutable.List)(Object.keys(sandbox));
  let sandboxVals = sandboxKeys.map(k => sandbox[k]).toArray();

  let parsed = new S.Module({
    directives: (0, _immutable.List)(),
    items: _immutable.List.of(new S.ExpressionStatement({
      expression: new S.FunctionExpression({
        isGenerator: false,
        name: null,
        params: new S.FormalParameters({
          items: sandboxKeys.map(param => {
            return new S.BindingIdentifier({
              name: _syntax2.default.from('identifier', param)
            });
          }),
          rest: null
        }),
        body: new S.FunctionBody({
          directives: _immutable.List.of(new S.Directive({
            rawValue: 'use strict'
          })),
          statements: _immutable.List.of(new S.ReturnStatement({
            expression: expr
          }))
        })
      })
    }))
  }).reduce(new _sweetToShiftReducer2.default(context.phase));

  let gen = (0, _shiftCodegen2.default)(parsed, new _shiftCodegen.FormattedCodeGen());
  let result = context.transform(gen);

  let val = context.loader.eval(result.code, context.store);
  return val.apply(undefined, sandboxVals);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sb2FkLXN5bnRheC5qcyJdLCJuYW1lcyI6WyJleHBhbmRDb21waWxldGltZSIsInNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXMiLCJldmFsQ29tcGlsZXRpbWVWYWx1ZSIsIlMiLCJfIiwidGVybSIsImNvbnRleHQiLCJzeW50YXhFeHBhbmRlciIsIm1lcmdlIiwicGhhc2UiLCJlbnYiLCJzdG9yZSIsImV4cGFuZCIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsImlzTGlzdCIsIm1hcCIsIkVycm9yIiwibmV4dCIsImV4cHIiLCJzYW5kYm94Iiwic3ludGF4VGVtcGxhdGUiLCJpZGVudCIsInRlbXBsYXRlTWFwIiwiZ2V0Iiwic2FuZGJveEtleXMiLCJPYmplY3QiLCJrZXlzIiwic2FuZGJveFZhbHMiLCJrIiwidG9BcnJheSIsInBhcnNlZCIsIk1vZHVsZSIsImRpcmVjdGl2ZXMiLCJpdGVtcyIsIm9mIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsImV4cHJlc3Npb24iLCJGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0dlbmVyYXRvciIsIm5hbWUiLCJwYXJhbXMiLCJGb3JtYWxQYXJhbWV0ZXJzIiwicGFyYW0iLCJCaW5kaW5nSWRlbnRpZmllciIsImZyb20iLCJyZXN0IiwiYm9keSIsIkZ1bmN0aW9uQm9keSIsIkRpcmVjdGl2ZSIsInJhd1ZhbHVlIiwic3RhdGVtZW50cyIsIlJldHVyblN0YXRlbWVudCIsInJlZHVjZSIsImdlbiIsInJlc3VsdCIsInRyYW5zZm9ybSIsInZhbCIsImxvYWRlciIsImV2YWwiLCJjb2RlIiwiYXBwbHkiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7O1FBV2dCQSxpQixHQUFBQSxpQjtRQWNBQyx5QixHQUFBQSx5QjtRQWdCQUMsb0IsR0FBQUEsb0I7O0FBekNoQjs7SUFBWUMsQzs7QUFDWjs7SUFBWUMsQzs7QUFDWjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7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QWdCLG9DQUFoQixDQUFWO0FBQ0EsTUFBSXdCLFNBQVNsRCxRQUFRbUQsU0FBUixDQUFrQkYsR0FBbEIsQ0FBYjs7QUFFQSxNQUFJRyxNQUFNcEQsUUFBUXFELE1BQVIsQ0FBZUMsSUFBZixDQUFvQkosT0FBT0ssSUFBM0IsRUFBaUN2RCxRQUFRSyxLQUF6QyxDQUFWO0FBQ0EsU0FBTytDLElBQUlJLEtBQUosQ0FBVUMsU0FBVixFQUFxQmxDLFdBQXJCLENBQVA7QUFDRCIsImZpbGUiOiJsb2FkLXN5bnRheC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFMgZnJvbSAnc3dlZXQtc3BlYyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IFN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgY29kZWdlbiwgeyBGb3JtYXR0ZWRDb2RlR2VuIH0gZnJvbSAnc2hpZnQtY29kZWdlbic7XG5pbXBvcnQgU3dlZXRUb1NoaWZ0UmVkdWNlciBmcm9tICcuL3N3ZWV0LXRvLXNoaWZ0LXJlZHVjZXInO1xuaW1wb3J0IFRlcm1FeHBhbmRlciBmcm9tICcuL3Rlcm0tZXhwYW5kZXInO1xuaW1wb3J0IEVudiBmcm9tICcuL2Vudic7XG5cbmltcG9ydCB7IHJlcGxhY2VUZW1wbGF0ZSB9IGZyb20gJy4vdGVtcGxhdGUtcHJvY2Vzc29yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZENvbXBpbGV0aW1lKHRlcm0sIGNvbnRleHQpIHtcbiAgLy8gZWFjaCBjb21waWxldGltZSB2YWx1ZSBuZWVkcyB0byBiZSBleHBhbmRlZCB3aXRoIGEgZnJlc2hcbiAgLy8gZW52aXJvbm1lbnQgYW5kIGluIHRoZSBuZXh0IGhpZ2hlciBwaGFzZVxuICBsZXQgc3ludGF4RXhwYW5kZXIgPSBuZXcgVGVybUV4cGFuZGVyKFxuICAgIF8ubWVyZ2UoY29udGV4dCwge1xuICAgICAgcGhhc2U6IGNvbnRleHQucGhhc2UgKyAxLFxuICAgICAgZW52OiBuZXcgRW52KCksXG4gICAgICBzdG9yZTogY29udGV4dC5zdG9yZSxcbiAgICB9KSxcbiAgKTtcblxuICByZXR1cm4gc3ludGF4RXhwYW5kZXIuZXhwYW5kKHRlcm0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlcyh2YWx1ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKExpc3QodmFsdWVzKSk7XG4gIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodmFsdWVzKSkge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKHNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXMpO1xuICB9IGVsc2UgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3JlcGxhY2VtZW50IHZhbHVlcyBmb3Igc3ludGF4IHRlbXBsYXRlIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyxcbiAgICApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKExpc3QodmFsdWVzKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gKEV4cHJlc3Npb24sIENvbnRleHQpIC0+IFtmdW5jdGlvbl1cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ29tcGlsZXRpbWVWYWx1ZShleHByOiBTLkV4cHJlc3Npb24sIGNvbnRleHQ6IGFueSkge1xuICBsZXQgc2FuZGJveCA9IHtcbiAgICBzeW50YXhUZW1wbGF0ZTogZnVuY3Rpb24oaWRlbnQsIC4uLnZhbHVlcykge1xuICAgICAgcmV0dXJuIHJlcGxhY2VUZW1wbGF0ZShcbiAgICAgICAgY29udGV4dC50ZW1wbGF0ZU1hcC5nZXQoaWRlbnQpLFxuICAgICAgICBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKHZhbHVlcyksXG4gICAgICApO1xuICAgIH0sXG4gIH07XG5cbiAgbGV0IHNhbmRib3hLZXlzID0gTGlzdChPYmplY3Qua2V5cyhzYW5kYm94KSk7XG4gIGxldCBzYW5kYm94VmFscyA9IHNhbmRib3hLZXlzLm1hcChrID0+IHNhbmRib3hba10pLnRvQXJyYXkoKTtcblxuICBsZXQgcGFyc2VkID0gbmV3IFMuTW9kdWxlKHtcbiAgICBkaXJlY3RpdmVzOiBMaXN0KCksXG4gICAgaXRlbXM6IExpc3Qub2YoXG4gICAgICBuZXcgUy5FeHByZXNzaW9uU3RhdGVtZW50KHtcbiAgICAgICAgZXhwcmVzc2lvbjogbmV3IFMuRnVuY3Rpb25FeHByZXNzaW9uKHtcbiAgICAgICAgICBpc0dlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICBwYXJhbXM6IG5ldyBTLkZvcm1hbFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgaXRlbXM6IHNhbmRib3hLZXlzLm1hcChwYXJhbSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUy5CaW5kaW5nSWRlbnRpZmllcih7XG4gICAgICAgICAgICAgICAgbmFtZTogU3ludGF4LmZyb20oJ2lkZW50aWZpZXInLCBwYXJhbSksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGJvZHk6IG5ldyBTLkZ1bmN0aW9uQm9keSh7XG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBMaXN0Lm9mKFxuICAgICAgICAgICAgICBuZXcgUy5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgIHJhd1ZhbHVlOiAndXNlIHN0cmljdCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN0YXRlbWVudHM6IExpc3Qub2YoXG4gICAgICAgICAgICAgIG5ldyBTLlJldHVyblN0YXRlbWVudCh7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICksXG4gIH0pLnJlZHVjZShuZXcgU3dlZXRUb1NoaWZ0UmVkdWNlcihjb250ZXh0LnBoYXNlKSk7XG5cbiAgbGV0IGdlbiA9IGNvZGVnZW4ocGFyc2VkLCBuZXcgRm9ybWF0dGVkQ29kZUdlbigpKTtcbiAgbGV0IHJlc3VsdCA9IGNvbnRleHQudHJhbnNmb3JtKGdlbik7XG5cbiAgbGV0IHZhbCA9IGNvbnRleHQubG9hZGVyLmV2YWwocmVzdWx0LmNvZGUsIGNvbnRleHQuc3RvcmUpO1xuICByZXR1cm4gdmFsLmFwcGx5KHVuZGVmaW5lZCwgc2FuZGJveFZhbHMpO1xufVxuIl19