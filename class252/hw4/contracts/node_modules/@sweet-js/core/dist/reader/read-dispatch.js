'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readSyntaxTemplate = readSyntaxTemplate;

var _readtable = require('readtable');

var _immutable = require('immutable');

var _tokens = require('../tokens');

const backtickEntry = {
  key: '`',
  mode: 'terminating',
  action: function readBacktick(stream, prefix, e) {
    if (prefix.isEmpty()) {
      return {
        type: _tokens.TokenType.LSYNTAX,
        value: stream.readString()
      };
    }

    return {
      type: _tokens.TokenType.RSYNTAX,
      value: stream.readString()
    };
  }
};

function readSyntaxTemplate(stream, prefix, exprAllowed, dispatchChar) {
  // return read('syntaxTemplate').first().token;
  // TODO: Can we simply tack 'syntaxTemplate' on the front and process it as a
  //       syntax macro?
  const prevTable = (0, _readtable.getCurrentReadtable)();
  (0, _readtable.setCurrentReadtable)(prevTable.extend(backtickEntry));

  const result = this.readUntil('`', stream, _immutable.List.of(updateSyntax(dispatchChar, this.readToken(stream, (0, _immutable.List)(), exprAllowed))), exprAllowed);

  (0, _readtable.setCurrentReadtable)(prevTable);
  return result;
}

function updateSyntax(prefix, token) {
  token.value = prefix + token.value;
  token.slice.text = prefix + token.slice.text;
  token.slice.start -= 1;
  token.slice.startLocation.position -= 1;
  return token;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFkZXIvcmVhZC1kaXNwYXRjaC5qcyJdLCJuYW1lcyI6WyJyZWFkU3ludGF4VGVtcGxhdGUiLCJiYWNrdGlja0VudHJ5Iiwia2V5IiwibW9kZSIsImFjdGlvbiIsInJlYWRCYWNrdGljayIsInN0cmVhbSIsInByZWZpeCIsImUiLCJpc0VtcHR5IiwidHlwZSIsIkxTWU5UQVgiLCJ2YWx1ZSIsInJlYWRTdHJpbmciLCJSU1lOVEFYIiwiZXhwckFsbG93ZWQiLCJkaXNwYXRjaENoYXIiLCJwcmV2VGFibGUiLCJleHRlbmQiLCJyZXN1bHQiLCJyZWFkVW50aWwiLCJvZiIsInVwZGF0ZVN5bnRheCIsInJlYWRUb2tlbiIsInRva2VuIiwic2xpY2UiLCJ0ZXh0Iiwic3RhcnQiLCJzdGFydExvY2F0aW9uIiwicG9zaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7O1FBOEJnQkEsa0IsR0FBQUEsa0I7O0FBNUJoQjs7QUFDQTs7QUFDQTs7QUFJQSxNQUFNQyxnQkFBZ0I7QUFDcEJDLE9BQUssR0FEZTtBQUVwQkMsUUFBTSxhQUZjO0FBR3BCQyxVQUFRLFNBQVNDLFlBQVQsQ0FDTkMsTUFETSxFQUVOQyxNQUZNLEVBR05DLENBSE0sRUFJTjtBQUNBLFFBQUlELE9BQU9FLE9BQVAsRUFBSixFQUFzQjtBQUNwQixhQUFPO0FBQ0xDLGNBQU0sa0JBQUdDLE9BREo7QUFFTEMsZUFBT04sT0FBT08sVUFBUDtBQUZGLE9BQVA7QUFJRDs7QUFFRCxXQUFPO0FBQ0xILFlBQU0sa0JBQUdJLE9BREo7QUFFTEYsYUFBT04sT0FBT08sVUFBUDtBQUZGLEtBQVA7QUFJRDtBQW5CbUIsQ0FBdEI7O0FBc0JPLFNBQVNiLGtCQUFULENBQ0xNLE1BREssRUFFTEMsTUFGSyxFQUdMUSxXQUhLLEVBSUxDLFlBSkssRUFLbUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsWUFBWSxxQ0FBbEI7QUFDQSxzQ0FBb0JBLFVBQVVDLE1BQVYsQ0FBaUJqQixhQUFqQixDQUFwQjs7QUFFQSxRQUFNa0IsU0FBUyxLQUFLQyxTQUFMLENBQ2IsR0FEYSxFQUViZCxNQUZhLEVBR2IsZ0JBQUtlLEVBQUwsQ0FDRUMsYUFBYU4sWUFBYixFQUEyQixLQUFLTyxTQUFMLENBQWVqQixNQUFmLEVBQXVCLHNCQUF2QixFQUErQlMsV0FBL0IsQ0FBM0IsQ0FERixDQUhhLEVBTWJBLFdBTmEsQ0FBZjs7QUFTQSxzQ0FBb0JFLFNBQXBCO0FBQ0EsU0FBT0UsTUFBUDtBQUNEOztBQUVELFNBQVNHLFlBQVQsQ0FBc0JmLE1BQXRCLEVBQThCaUIsS0FBOUIsRUFBcUM7QUFDbkNBLFFBQU1aLEtBQU4sR0FBY0wsU0FBU2lCLE1BQU1aLEtBQTdCO0FBQ0FZLFFBQU1DLEtBQU4sQ0FBWUMsSUFBWixHQUFtQm5CLFNBQVNpQixNQUFNQyxLQUFOLENBQVlDLElBQXhDO0FBQ0FGLFFBQU1DLEtBQU4sQ0FBWUUsS0FBWixJQUFxQixDQUFyQjtBQUNBSCxRQUFNQyxLQUFOLENBQVlHLGFBQVosQ0FBMEJDLFFBQTFCLElBQXNDLENBQXRDO0FBQ0EsU0FBT0wsS0FBUDtBQUNEIiwiZmlsZSI6InJlYWQtZGlzcGF0Y2guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRDdXJyZW50UmVhZHRhYmxlLCBzZXRDdXJyZW50UmVhZHRhYmxlIH0gZnJvbSAncmVhZHRhYmxlJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgVG9rZW5UeXBlIGFzIFRUIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuaW1wb3J0IHR5cGUgeyBDaGFyU3RyZWFtIH0gZnJvbSAncmVhZHRhYmxlJztcblxuY29uc3QgYmFja3RpY2tFbnRyeSA9IHtcbiAga2V5OiAnYCcsXG4gIG1vZGU6ICd0ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZEJhY2t0aWNrKFxuICAgIHN0cmVhbTogQ2hhclN0cmVhbSxcbiAgICBwcmVmaXg6IExpc3Q8YW55PixcbiAgICBlOiBib29sZWFuLFxuICApIHtcbiAgICBpZiAocHJlZml4LmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVFQuTFNZTlRBWCxcbiAgICAgICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUVC5SU1lOVEFYLFxuICAgICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKCksXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3ludGF4VGVtcGxhdGUoXG4gIHN0cmVhbTogQ2hhclN0cmVhbSxcbiAgcHJlZml4OiBMaXN0PGFueT4sXG4gIGV4cHJBbGxvd2VkOiBib29sZWFuLFxuICBkaXNwYXRjaENoYXI6IHN0cmluZyxcbik6IExpc3Q8YW55PiB8IHsgdHlwZTogdHlwZW9mIFRULlJTWU5UQVgsIHZhbHVlOiBzdHJpbmcgfSB7XG4gIC8vIHJldHVybiByZWFkKCdzeW50YXhUZW1wbGF0ZScpLmZpcnN0KCkudG9rZW47XG4gIC8vIFRPRE86IENhbiB3ZSBzaW1wbHkgdGFjayAnc3ludGF4VGVtcGxhdGUnIG9uIHRoZSBmcm9udCBhbmQgcHJvY2VzcyBpdCBhcyBhXG4gIC8vICAgICAgIHN5bnRheCBtYWNybz9cbiAgY29uc3QgcHJldlRhYmxlID0gZ2V0Q3VycmVudFJlYWR0YWJsZSgpO1xuICBzZXRDdXJyZW50UmVhZHRhYmxlKHByZXZUYWJsZS5leHRlbmQoYmFja3RpY2tFbnRyeSkpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZFVudGlsKFxuICAgICdgJyxcbiAgICBzdHJlYW0sXG4gICAgTGlzdC5vZihcbiAgICAgIHVwZGF0ZVN5bnRheChkaXNwYXRjaENoYXIsIHRoaXMucmVhZFRva2VuKHN0cmVhbSwgTGlzdCgpLCBleHByQWxsb3dlZCkpLFxuICAgICksXG4gICAgZXhwckFsbG93ZWQsXG4gICk7XG5cbiAgc2V0Q3VycmVudFJlYWR0YWJsZShwcmV2VGFibGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW50YXgocHJlZml4LCB0b2tlbikge1xuICB0b2tlbi52YWx1ZSA9IHByZWZpeCArIHRva2VuLnZhbHVlO1xuICB0b2tlbi5zbGljZS50ZXh0ID0gcHJlZml4ICsgdG9rZW4uc2xpY2UudGV4dDtcbiAgdG9rZW4uc2xpY2Uuc3RhcnQgLT0gMTtcbiAgdG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbi5wb3NpdGlvbiAtPSAxO1xuICByZXR1cm4gdG9rZW47XG59XG4iXX0=