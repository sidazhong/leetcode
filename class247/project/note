Heterogeneous Architecture

https://www.eet-china.com/mp/a62647.html
https://zhuanlan.zhihu.com/p/57541775


Simple CPU desgin
https://www.circuitlab.com/editor/#?id=7pq5wm&from=homepage
https://www.bilibili.com/video/BV1S7411f7sZ?from=search&seid=15471097483429076427&spm_id_from=333.337.0.0
https://github.com/luyufan498/CPU_start_from_0


Simple CPU desgin

Introduction
在高级汇编语言中, 源代码会先由Lexer生成token，在由Parser把生成的token组成Abstruct Syntax tree, 最后由compiler通过VM生成Opcode.
这些Opcode会被机器直接执行。However, OPCODE类似 "ADD","ASSIGN","JUMP","IS_EQUAL", 机器是如何通过电路和晶体管把
这些数字运算，循环，逻辑判断，变量存储实现的呢？
这个project会设计一个简单的CPU，实现一行最简单的汇编语言代码，目的是探索更底层的电路原理,
把之前汇编语言的知识串联起来,以便于以后写出更好，更优化的代码。

Introduction
In programing language, the source code will first generate the token by Lexer, then the Parser will compose the generated token into the Abstruct Syntax tree, and finally the Opcode will be generated by the compiler through the VM.
These Opcodes will be executed directly by the machine. However, OPCODE such like "ADD","ASSIGN","JUMP","IS_EQUAL", how does the machine know these symples and using transistors to execute it.

This project will design a simple CPU to implement a single line of programing code. The purpose is to understand the organization of basic computer circurt.

Objective
Design a simple CPU ,Enter a positive integer N, calculate the sum of the numbers from 0 to N

Schedule
Prepaire environment    (week 2)
Design a CPU circuit    (week 6)
    Memory              
    Processor register
    Arithmetic logic unit
    Control unit
Implement the circuit diagram with VHDL code    (week10)
    Memory
    Processor register
    Arithmetic logic unit
    Control unit
Test Code (week 11)
simulate code (week 12)
report (week 13)

Language
    VHDL
Tools
    vivado 
    CircuitLab, https://www.circuitlab.com/
    still researching...


http://libaccess.sjlibrary.org/login?url=https://ieeexplore.ieee.org/document/4019522
=================================================================================================================================================

安装vivado
https://danielmangum.com/posts/vivado-2020-x-ubuntu-20-04/

运行vivado 
./tools/Xilinx/Vivado/2021.1/bin/vivado

细节
语言：verilog 和 VHDL 混合
板子是：basys3

https://digilent.com/shop/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/

芯片名字是：XC7A35T-1CPG236C	

28nm 可以介绍一下 https://www.zhihu.com/question/407544291
图片 https://i1.wp.com/semiengineering.com/wp-content/uploads/2014/07/28nmfinfets.png

Vivado 功能
	IP：设计好的模块，intellectual property not Internet Protocols  
	simulation：跟高级语言编译不一样，测试需要很长时间1 2 小时，需要先测试在编译
	RTL analysis： 直观图
	synthesis： 测试代码用，编译，理想电路
	implementation： 实现


冯诺依曼结构：	是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构
https://www.bilibili.com/read/cv225659
哈佛结构： 是一种将程序指令储存和数据储存分开的存储器结构(Split Cache)。


Memory:
	 程序也放进去，这个叫冯诺依曼结构，按照地址顺序执行。 程序和数据合并在一起
	 PC：
	 	程序指针	Program counter， instruction counter
	 	用来指向一个地址，按顺序读memroy数据，下一次执行地址
	 	PCload：
	 		载入信号，为1会读PC
	 Jmux：
	 	选择器，跳转指令
	 	跟IR配合把地址输入进来
	 ROM （instruction）：
	 	输入PC地址
	 	输出instruction
	 IRload：
	 	为1,才会出去数据
	 IR：
	 	instruction register：holds the instruction currently being executed or decoded.
	 	后4位，因为程序不会按顺序执行，可能有循环

register:
	Registers usually consist of a small amount of fast storage, 
	although some registers have specific hardware functions, and may be read-only or write-only.

寄存器：
	instruction 读出来以后
	做运算用的
	RF：
		register file
			A register file is an array of processor registers in a central processing unit
			access multiple different physical registers
			用来临时储存地址的
			4*10 个寄存器，每个寄存器10 bit
			read / write
			WA write address, 
			WE write enable,
			RAE read A enable
			RAA	read A address
			RBA	read B enable
			RBB	read B enable
		ALU 
			Arithmetic Logic Unit (ALU)
			从register file 里面取两个寄存器，进行操作
			A=A+B 所以有最右侧外面那个线
		OE：
			out put enable
		MUX:
			multiplexer
			A multiplexer (MUX) is a device that can receive multiple input signals 
			and synthesize a single output signal in a recoverable manner for each input signal
		NOR:
			IF I++ > B: 跳出循环  1 bit 的output，如果AB运算结果>0

OPCODE:
	MOV: Rdd <- Rss 对于RF的操作		1ddss dd和ss都是寄存器地址，寄存器地址 2位
	JMP: aaaa 为4位的 instructions
	ALU: 运算
		Cal_value 加固定运算，越过RF，直接进入ALU
	HALT: 就是reset=0
	
机器最精通循环，重复性劳动

或非门就是 a==0

CPU：
	phase 类似clock 是一个4bit的循环
	数据流的概念，每一级都有一个开关，用来控制数据进出
	编码就是IR的地址bit

指令：
	R1,R2,R3,R4 有4个寄存器
	1. READ INPUT TO R3
	2. INIT RO=1
	3. INIT R1=0
	
ADDRESS		INSTRUCTION		
0001			0000100011	READ INPUT TO R3
0010			1000000001	INIT RO=1
0011			1010000000	INIT R1=0
0100			0100010100	R1+=R0
0101			0010000001	R0++
0110			0001110011	IF RO<R3 THEN Z=0 ELSE Z=1
0111			0001010011	IF Z==0 THEN GO ADDR 03 ELSE GO NEXT ADDR
1000			0000100101	OUTPUT R1
1001			0000000000	OVER




ADDRESS		INSTRUCTION		
0001			0000100011	READ INPUT TO R3
0010			1000000000	INIT RO=0
0011			1010000000	INIT R1=0
0100			0100010100	R1+=R0
0101			0010000001	R0++
0110			0001110011	IF RO<R3 THEN Z=0 ELSE Z=1
0111			0001010011	IF Z==0 THEN GO ADDR 03 ELSE GO NEXT ADDR
1000			0000100101	OUTPUT R1
1001			0000000000	OVER



https://zhuanlan.zhihu.com/p/109574885





1. 先介绍要做一个CPU
2. 提出需求，并表明这不是一个机器能明白的事情
3. 写出高级语言，机器还是无法理解
4. 写出到OPCODE的经过， 但机器还是无法理解
5. 需要一个instruction table
6. 链接instruction table 到 OPCODE
7. 变成带有instruction的OPCODE，转化为2进制代码
8. 介绍一下冯诺依曼结构，2进机制代码导入到ROM里

9. 介绍CPU Control Unit
	1.刚才的2进机制代码在ROM里
	2.驱动ROM的是PC，所以PC一直在increment 
	3.ROM的指令传递到IR里，整个模块输出IR指令
	4.这是正常情况，因为有JUMP的命令，所以PC不一定一直increment
	
10. 介绍CPU Processing unit
	1. 先介绍ALU ，但是没法存储变量，所以只是一个计算器而已
	2. 介绍RF，可以把临时变量寄存在里面，外头一根线是要完成，A=A+B
	3. 介绍XOR，可以jump跳转，用IF举例子，在用while举例子

11. 介绍CPU pipeline
	1. 先玩一个小游戏
	2. CPU就是一个大陷阱，需要把公主营救出来，input就是公主，都是event driven的逻辑门，不可以全部打开，要按顺序一个一个来
	3. 出图，表明顺序，特别指出 A=A+B
	
12. 举一个例子，跳舞
			留声机就是Control Unit，磁盘是fly me to the moon程序，磁头是PC，喇叭是IR
			舞者就是Processing Unit，头是Input，手臂是RF，身体是ALU，腿是XOR跳转，脚是output
			15秒之内需要完成一个指令，一共7个指令
		
13. simulation
	1. testbench
	2. 介绍一下vivado，说软件比硬件发展的更快
	3. 说明input，output
	4. 说明RF的变量
	5. instructin 和 phase
	
14. 结束
	1. 还可从购买真实的芯片，把程序刻录上去。




Gramophone (Control unit)
	disk record (ROM)
	needle pin (PC)
	horn (IR)






















































